{"version":3,"file":"index.js","sources":["../src/Validation.ts"],"sourcesContent":["\r\nimport { Plugin, Path, StateValueAtPath, State } from '@hookstate/core';\r\n\r\nexport type ValidationSeverity = 'error' | 'warning';\r\n\r\nexport interface ValidationError {\r\n    readonly message: string;\r\n    readonly path: Path;\r\n    readonly severity: ValidationSeverity;\r\n}\r\n\r\nexport interface ValidationExtensions<S> {\r\n    validate(attachRule: (value: S) => boolean,\r\n        message: string | ((value: S) => string),\r\n        severity?: ValidationSeverity): void,\r\n    validShallow(): boolean,\r\n    valid(): boolean,\r\n    invalidShallow(): boolean,\r\n    invalid(): boolean,\r\n    firstError(\r\n        filter?: (e: ValidationError) => boolean,\r\n        depth?: number\r\n    ): Partial<ValidationError>,\r\n    errors(\r\n        filter?: (e: ValidationError) => boolean,\r\n        depth?: number,\r\n        first?: boolean\r\n    ): ReadonlyArray<ValidationError>,\r\n}\r\n\r\nconst PluginID = Symbol('Validate');\r\n\r\nconst emptyErrors: ValidationError[] = []\r\n\r\ninterface ValidationRule {\r\n    readonly message: string | ((value: StateValueAtPath) => string)\r\n    readonly rule: (v: StateValueAtPath) => boolean\r\n    readonly severity: ValidationSeverity;\r\n}\r\n\r\nclass ValidationPluginInstance<S> {\r\n    private storeRules = {};\r\n\r\n    getRulesAndNested(path: Path): [ValidationRule[], string[]] {\r\n        let result = this.storeRules;\r\n        path.forEach(p => {\r\n            if (typeof p === 'number') {\r\n                p = '*' // limitation: support only validation for each element of array\r\n            }\r\n            result = result && (result[p])\r\n        });\r\n        return [result && result[PluginID] ? Array.from(result[PluginID].values()) : [],\r\n            result ? Object.keys(result) : []];\r\n    }\r\n    addRule(path: Path, r: ValidationRule) {\r\n        let result = this.storeRules;\r\n        path.forEach((p, i) => {\r\n            if (typeof p === 'number') {\r\n                p = '*' // limitation: support only validation for each element of array\r\n            }\r\n            result[p] = result[p] || {}\r\n            result = result[p]\r\n        });\r\n        const existingRules: Map<string, ValidationRule> | undefined = result[PluginID];\r\n        const newRuleFunction = r.rule.toString();\r\n        if (existingRules) {\r\n            if (existingRules.has(newRuleFunction)) {\r\n                return;\r\n            }\r\n            existingRules.set(newRuleFunction, r);\r\n            return;\r\n        }\r\n        const newMap: Map<string, ValidationRule> = new Map();\r\n        newMap.set(newRuleFunction, r);\r\n        result[PluginID] = newMap;\r\n    }\r\n\r\n    getErrors(l: State<StateValueAtPath>,\r\n        depth: number,\r\n        filter?: (e: ValidationError) => boolean,\r\n        first?: boolean): ReadonlyArray<ValidationError> {\r\n\r\n        let result: ValidationError[] = [];\r\n        const consistentResult = () => result.length === 0 ? emptyErrors : result;\r\n\r\n        if (depth === 0) {\r\n            return consistentResult();\r\n        }\r\n\r\n        const [existingRules, nestedRulesKeys] = this.getRulesAndNested(l.path);\r\n        for (let i = 0; i < existingRules.length; i += 1) {\r\n            const r = existingRules[i];\r\n            if (!r.rule(l.value)) {\r\n                const err = {\r\n                    path: l.path,\r\n                    message: typeof r.message === 'function' ? r.message(l.value) : r.message,\r\n                    severity: r.severity\r\n                };\r\n                if (!filter || filter(err)) {\r\n                    result.push(err)\r\n                    if (first) {\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (depth === 1) {\r\n            return consistentResult();\r\n        }\r\n        if (nestedRulesKeys.length === 0) {\r\n            // console.log('getResults nested rules 0 length', result)\r\n            return consistentResult();\r\n        }\r\n        const nestedInst = l;\r\n        if (nestedInst.keys === undefined) {\r\n            // console.log('getResults no nested inst', result)\r\n            return consistentResult();\r\n        }\r\n        if (Array.isArray(nestedInst)) {\r\n            if (nestedRulesKeys.includes('*')) {\r\n                for (let i = 0; i < nestedInst.length; i += 1) {\r\n                    const n = nestedInst[i];\r\n                    result = result.concat(\r\n                        Validation(n as State<StateValueAtPath>)\r\n                            .errors(filter, depth - 1, first));\r\n                    if (first && result.length > 0) {\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n            // validation for individual array elements is not supported, it is covered by foreach above\r\n            // for (let i = 0; i < nestedRulesKeys.length; i += 1) {\r\n            //     const k = nestedRulesKeys[i];\r\n            //     // Validation rule exists,\r\n            //     // but the corresponding nested link may not be created,\r\n            //     // (because it may not be inferred automatically)\r\n            //     // because the original array value cas miss the corresponding index\r\n            //     // The design choice is to skip validation in this case.\r\n            //     // A client can define per array level validation rule,\r\n            //     // where existance of the index can be cheched.\r\n            //     if (nestedInst[k] !== undefined) {\r\n            //         result = result.concat((nestedInst[k] as State<StateValueAtPath, ValidationExtensions>)\r\n            //             .extended.errors(filter, depth - 1, first));\r\n            //         if (first && result.length > 0) {\r\n            //             return result;\r\n            //         }\r\n            //     }\r\n            // }\r\n        } else {\r\n            for (let i = 0; i < nestedRulesKeys.length; i += 1) {\r\n                const k = nestedRulesKeys[i];\r\n                // Validation rule exists,\r\n                // but the corresponding nested link may not be created,\r\n                // (because it may not be inferred automatically)\r\n                // because the original array value cas miss the corresponding index\r\n                // The design choice is to skip validation in this case.\r\n                // A client can define per array level validation rule,\r\n                // where existance of the index can be cheched.\r\n                if (nestedInst[k] !== undefined) {\r\n                    result = result.concat(\r\n                        Validation(nestedInst[k] as State<StateValueAtPath>)\r\n                            .errors(filter, depth - 1, first));\r\n                    if (first && result.length > 0) {\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return consistentResult();\r\n    }\r\n}\r\n\r\n// tslint:disable-next-line: function-name\r\nexport function Validation(): Plugin;\r\nexport function Validation<S>($this: State<S>): ValidationExtensions<S>;\r\nexport function Validation<S>($this?: State<S>): Plugin | ValidationExtensions<S> {\r\n    if ($this) {\r\n        let state = $this;\r\n\r\n        const [plugin] = state.attach(PluginID);\r\n        if (plugin instanceof Error) {\r\n            throw plugin\r\n        }\r\n        const instance = plugin as ValidationPluginInstance<S>;\r\n\r\n        const inst = instance;\r\n        return {\r\n            validate: (r, m, s) => {\r\n                inst.addRule(state.path, {\r\n                    rule: r,\r\n                    message: m,\r\n                    severity: s || 'error'\r\n                })\r\n            },\r\n            validShallow(): boolean {\r\n                return inst.getErrors(state, 1, undefined, true).length === 0\r\n            },\r\n            valid(): boolean {\r\n                return inst.getErrors(state, Number.MAX_SAFE_INTEGER, undefined, true).length === 0\r\n            },\r\n            invalidShallow(): boolean {\r\n                return inst.getErrors(state, 1, undefined, true).length !== 0\r\n            },\r\n            invalid(): boolean {\r\n                return inst.getErrors(state, Number.MAX_SAFE_INTEGER, undefined, true).length !== 0\r\n            },\r\n            errors: (filter, depth, first) => {\r\n                return inst.getErrors(state, depth === undefined ? Number.MAX_SAFE_INTEGER : depth, filter, first);\r\n            },\r\n            firstError: (filter, depth) => {\r\n                const r = inst.getErrors(state, depth === undefined ? Number.MAX_SAFE_INTEGER : depth, filter, true);\r\n                if (r.length === 0) {\r\n                    return {};\r\n                }\r\n                return r[0];\r\n            },\r\n        }\r\n    }\r\n    return {\r\n        id: PluginID,\r\n        init: () => new ValidationPluginInstance() as {}\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}