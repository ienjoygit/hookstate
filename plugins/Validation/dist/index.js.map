{"version":3,"file":"index.js","sources":["../src/Validation.ts"],"sourcesContent":["\nimport { Plugin, PluginTypeMarker, Path, StateLink, StateValueAtPath } from '@hookstate/core';\n\nexport enum ValidationSeverity {\n    WARNING = 1,\n    ERROR = 2\n}\n\nexport interface ValidationRule {\n    readonly message: string | ((value: StateValueAtPath) => string)\n    readonly rule: (v: StateValueAtPath) => boolean\n    readonly severity: ValidationSeverity;\n}\n\nexport interface ValidationError {\n    readonly message: string;\n    readonly path: Path;\n    readonly severity: ValidationSeverity;\n}\n\nexport interface ValidationExtensions {\n    // validate(rule: (target: S, targetLink: StateLink<S, E>) => boolean, message: string): void,\n    readonly validShallow: boolean,\n    readonly valid: boolean,\n    readonly invalidShallow: boolean,\n    readonly invalid: boolean,\n    firstError(\n        filter?: (e: ValidationError) => boolean,\n        depth?: number\n    ): Partial<ValidationError>,\n    errors(\n        filter?: (e: ValidationError) => boolean,\n        depth?: number,\n        first?: boolean\n    ): ReadonlyArray<ValidationError>,\n}\n\nconst PluginID = Symbol('Validate');\n\nconst emptyErrors: ValidationError[] = []\n\n// tslint:disable-next-line: function-name\nexport function Validation<S, E extends {}>(): ((unused: PluginTypeMarker<S, E>) => Plugin<E, ValidationExtensions>);\nexport function Validation<S, E extends {}>(\n    attachRule: (value: S) => boolean,\n    message: string | ((value: S) => string)\n): ((unused: PluginTypeMarker<S, E>) => Plugin<E, ValidationExtensions>);\nexport function Validation<S, E extends {}>(\n    attachRule: (value: S) => boolean,\n    message: string | ((value: S) => string),\n    severity: ValidationSeverity\n): ((unused: PluginTypeMarker<S, E>) => Plugin<E, ValidationExtensions>);\nexport function Validation<S, E extends {}>(\n    attachRule?: (value: S) => boolean,\n    message?: string | ((value: S) => string),\n    severity?: ValidationSeverity\n): ((unused: PluginTypeMarker<S, E>) => Plugin<E, ValidationExtensions>) {\n\n    return () => {\n        const storeRules = {};\n        function getRulesAndNested(path: Path): [ValidationRule[], string[]] {\n            let result = storeRules;\n            path.forEach(p => {\n                if (typeof p === 'number') {\n                    p = '*' // limitation: support only validation for each element of array\n                }\n                result = result && (result[p])\n            });\n            return [result && result[PluginID] ? Array.from(result[PluginID].values()) : [],\n                result ? Object.keys(result) : []];\n        }\n        function addRule(path: Path, r: ValidationRule) {\n            let result = storeRules;\n            path.forEach((p, i) => {\n                if (typeof p === 'number') {\n                    p = '*' // limitation: support only validation for each element of array\n                }\n                result[p] = result[p] || {}\n                result = result[p]\n            });\n            const existingRules: Map<string, ValidationRule> | undefined = result[PluginID];\n            const newRuleFunction = r.rule.toString();\n            if (existingRules) {\n                if (existingRules.has(newRuleFunction)) {\n                    return;\n                }\n                existingRules.set(newRuleFunction, r);\n                return;\n            }\n            const newMap: Map<string, ValidationRule> = new Map();\n            newMap.set(newRuleFunction, r);\n            result[PluginID] = newMap;\n        }\n\n        function getErrors(l: StateLink<StateValueAtPath>,\n            depth: number,\n            filter?: (e: ValidationError) => boolean,\n            first?: boolean): ReadonlyArray<ValidationError> {\n\n            let result: ValidationError[] = [];\n            const consistentResult = () => result.length === 0 ? emptyErrors : result;\n\n            if (depth === 0) {\n                return consistentResult();\n            }\n\n            const [existingRules, nestedRulesKeys] = getRulesAndNested(l.path);\n            for (let i = 0; i < existingRules.length; i += 1) {\n                const r = existingRules[i];\n                if (!r.rule(l.value)) {\n                    const err = {\n                        path: l.path,\n                        message: typeof r.message === 'function' ? r.message(l.value) : r.message,\n                        severity: r.severity\n                    };\n                    if (!filter || filter(err)) {\n                        result.push(err)\n                        if (first) {\n                            return result;\n                        }\n                    }\n                }\n            }\n            if (depth === 1) {\n                return consistentResult();\n            }\n            if (nestedRulesKeys.length === 0) {\n                // console.log('getResults nested rules 0 length', result)\n                return consistentResult();\n            }\n            const nestedInst = l.nested;\n            if (nestedInst === undefined) {\n                // console.log('getResults no nested inst', result)\n                return consistentResult();\n            }\n            if (Array.isArray(nestedInst)) {\n                if (nestedRulesKeys.includes('*')) {\n                    for (let i = 0; i < nestedInst.length; i += 1) {\n                        const n = nestedInst[i];\n                        result = result.concat((n as StateLink<StateValueAtPath, ValidationExtensions>)\n                            .extended.errors(filter, depth - 1, first));\n                        if (first && result.length > 0) {\n                            return result;\n                        }\n                    }\n                }\n                // validation for individual array elements is not supported, it is covered by foreach above\n                // for (let i = 0; i < nestedRulesKeys.length; i += 1) {\n                //     const k = nestedRulesKeys[i];\n                //     // Validation rule exists,\n                //     // but the corresponding nested link may not be created,\n                //     // (because it may not be inferred automatically)\n                //     // because the original array value cas miss the corresponding index\n                //     // The design choice is to skip validation in this case.\n                //     // A client can define per array level validation rule,\n                //     // where existance of the index can be cheched.\n                //     if (nestedInst[k] !== undefined) {\n                //         result = result.concat((nestedInst[k] as StateLink<StateValueAtPath, ValidationExtensions>)\n                //             .extended.errors(filter, depth - 1, first));\n                //         if (first && result.length > 0) {\n                //             return result;\n                //         }\n                //     }\n                // }\n            } else {\n                for (let i = 0; i < nestedRulesKeys.length; i += 1) {\n                    const k = nestedRulesKeys[i];\n                    // Validation rule exists,\n                    // but the corresponding nested link may not be created,\n                    // (because it may not be inferred automatically)\n                    // because the original array value cas miss the corresponding index\n                    // The design choice is to skip validation in this case.\n                    // A client can define per array level validation rule,\n                    // where existance of the index can be cheched.\n                    if (nestedInst[k] !== undefined) {\n                        result = result.concat((nestedInst[k] as StateLink<StateValueAtPath, ValidationExtensions>)\n                            .extended.errors(filter, depth - 1, first));\n                        if (first && result.length > 0) {\n                            return result;\n                        }\n                    }\n                }\n            }\n            return consistentResult();\n        }\n\n        return {\n            id: PluginID,\n            instanceFactory: () => ({\n                get config(): ValidationRule | undefined {\n                    if (attachRule !== undefined && message !== undefined) {\n                        return { rule: attachRule, message: message, severity: severity || ValidationSeverity.ERROR }\n                    }\n                    return undefined;\n                },\n                onAttach: (path, plugin) => {\n                    const config = (plugin as unknown as { config: ValidationRule | undefined }).config;\n                    if (config) {\n                        addRule(path, config);\n                    }\n                },\n                extensions: ['valid', 'invalid', 'errors', 'firstError'],\n                extensionsFactory: (l) => ({\n                    get validShallow(): boolean {\n                        return getErrors(l, 1).length === 0\n                    },\n                    get valid(): boolean {\n                        return getErrors(l, Number.MAX_SAFE_INTEGER).length === 0\n                    },\n                    get invalidShallow(): boolean {\n                        return getErrors(l, 1).length !== 0\n                    },\n                    get invalid(): boolean {\n                        return getErrors(l, Number.MAX_SAFE_INTEGER).length !== 0\n                    },\n                    errors(filter?: (e: ValidationError) => boolean,\n                        depth?: number,\n                        first?: boolean): ReadonlyArray<ValidationError> {\n                        return getErrors(l, depth === undefined ? Number.MAX_SAFE_INTEGER : depth, filter, first);\n                    },\n                    firstError(filter?: (e: ValidationError) => boolean, depth?: number) {\n                        const r = getErrors(l, depth === undefined ? Number.MAX_SAFE_INTEGER : depth, filter, true);\n                        if (r.length === 0) {\n                            return {};\n                        }\n                        return r;\n                    },\n                })\n            })\n        }\n    }\n}\n"],"names":["ValidationSeverity"],"mappings":"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"}