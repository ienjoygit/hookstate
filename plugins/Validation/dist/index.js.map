{"version":3,"file":"index.js","sources":["../src/Validation.ts"],"sourcesContent":["\nimport { Plugin, Path, StateValueAtPath, State, self } from '@hookstate/core';\n\nexport type ValidationSeverity = 'error' | 'warning';\n\nexport interface ValidationError {\n    readonly message: string;\n    readonly path: Path;\n    readonly severity: ValidationSeverity;\n}\n\nexport interface ValidationExtensions<S> {\n    validate(attachRule: (value: S) => boolean,\n        message: string | ((value: S) => string),\n        severity?: ValidationSeverity): void,\n    validShallow(): boolean,\n    valid(): boolean,\n    invalidShallow(): boolean,\n    invalid(): boolean,\n    firstError(\n        filter?: (e: ValidationError) => boolean,\n        depth?: number\n    ): Partial<ValidationError>,\n    errors(\n        filter?: (e: ValidationError) => boolean,\n        depth?: number,\n        first?: boolean\n    ): ReadonlyArray<ValidationError>,\n}\n\nconst PluginID = Symbol('Validate');\n\nconst emptyErrors: ValidationError[] = []\n\ninterface ValidationRule {\n    readonly message: string | ((value: StateValueAtPath) => string)\n    readonly rule: (v: StateValueAtPath) => boolean\n    readonly severity: ValidationSeverity;\n}\n\nclass ValidationPluginInstance<S> {\n    private storeRules = {};\n\n    getRulesAndNested(path: Path): [ValidationRule[], string[]] {\n        let result = this.storeRules;\n        path.forEach(p => {\n            if (typeof p === 'number') {\n                p = '*' // limitation: support only validation for each element of array\n            }\n            result = result && (result[p])\n        });\n        return [result && result[PluginID] ? Array.from(result[PluginID].values()) : [],\n            result ? Object.keys(result) : []];\n    }\n    addRule(path: Path, r: ValidationRule) {\n        let result = this.storeRules;\n        path.forEach((p, i) => {\n            if (typeof p === 'number') {\n                p = '*' // limitation: support only validation for each element of array\n            }\n            result[p] = result[p] || {}\n            result = result[p]\n        });\n        const existingRules: Map<string, ValidationRule> | undefined = result[PluginID];\n        const newRuleFunction = r.rule.toString();\n        if (existingRules) {\n            if (existingRules.has(newRuleFunction)) {\n                return;\n            }\n            existingRules.set(newRuleFunction, r);\n            return;\n        }\n        const newMap: Map<string, ValidationRule> = new Map();\n        newMap.set(newRuleFunction, r);\n        result[PluginID] = newMap;\n    }\n\n    getErrors(l: State<StateValueAtPath>,\n        depth: number,\n        filter?: (e: ValidationError) => boolean,\n        first?: boolean): ReadonlyArray<ValidationError> {\n\n        let result: ValidationError[] = [];\n        const consistentResult = () => result.length === 0 ? emptyErrors : result;\n\n        if (depth === 0) {\n            return consistentResult();\n        }\n\n        const [existingRules, nestedRulesKeys] = this.getRulesAndNested(l[self].path);\n        for (let i = 0; i < existingRules.length; i += 1) {\n            const r = existingRules[i];\n            if (!r.rule(l[self].value)) {\n                const err = {\n                    path: l[self].path,\n                    message: typeof r.message === 'function' ? r.message(l[self].value) : r.message,\n                    severity: r.severity\n                };\n                if (!filter || filter(err)) {\n                    result.push(err)\n                    if (first) {\n                        return result;\n                    }\n                }\n            }\n        }\n        if (depth === 1) {\n            return consistentResult();\n        }\n        if (nestedRulesKeys.length === 0) {\n            // console.log('getResults nested rules 0 length', result)\n            return consistentResult();\n        }\n        const nestedInst = l;\n        if (nestedInst[self].keys === undefined) {\n            // console.log('getResults no nested inst', result)\n            return consistentResult();\n        }\n        if (Array.isArray(nestedInst)) {\n            if (nestedRulesKeys.includes('*')) {\n                for (let i = 0; i < nestedInst.length; i += 1) {\n                    const n = nestedInst[i];\n                    result = result.concat(\n                        Validation(n as State<StateValueAtPath>)\n                            .errors(filter, depth - 1, first));\n                    if (first && result.length > 0) {\n                        return result;\n                    }\n                }\n            }\n            // validation for individual array elements is not supported, it is covered by foreach above\n            // for (let i = 0; i < nestedRulesKeys.length; i += 1) {\n            //     const k = nestedRulesKeys[i];\n            //     // Validation rule exists,\n            //     // but the corresponding nested link may not be created,\n            //     // (because it may not be inferred automatically)\n            //     // because the original array value cas miss the corresponding index\n            //     // The design choice is to skip validation in this case.\n            //     // A client can define per array level validation rule,\n            //     // where existance of the index can be cheched.\n            //     if (nestedInst[k] !== undefined) {\n            //         result = result.concat((nestedInst[k] as State<StateValueAtPath, ValidationExtensions>)\n            //             .extended.errors(filter, depth - 1, first));\n            //         if (first && result.length > 0) {\n            //             return result;\n            //         }\n            //     }\n            // }\n        } else {\n            for (let i = 0; i < nestedRulesKeys.length; i += 1) {\n                const k = nestedRulesKeys[i];\n                // Validation rule exists,\n                // but the corresponding nested link may not be created,\n                // (because it may not be inferred automatically)\n                // because the original array value cas miss the corresponding index\n                // The design choice is to skip validation in this case.\n                // A client can define per array level validation rule,\n                // where existance of the index can be cheched.\n                if (nestedInst[k] !== undefined) {\n                    result = result.concat(\n                        Validation(nestedInst[k] as State<StateValueAtPath>)\n                            .errors(filter, depth - 1, first));\n                    if (first && result.length > 0) {\n                        return result;\n                    }\n                }\n            }\n        }\n        return consistentResult();\n    }\n}\n\n// tslint:disable-next-line: function-name\nexport function Validation(): Plugin;\nexport function Validation<S>($this: State<S>): ValidationExtensions<S>;\nexport function Validation<S>($this?: State<S>): Plugin | ValidationExtensions<S> {\n    if ($this) {\n        let state = $this;\n\n        const [plugin] = state[self].attach(PluginID);\n        if (plugin instanceof Error) {\n            throw plugin\n        }\n        const instance = plugin as ValidationPluginInstance<S>;\n\n        const inst = instance;\n        return {\n            validate: (r, m, s) => {\n                inst.addRule(state[self].path, {\n                    rule: r,\n                    message: m,\n                    severity: s || 'error'\n                })\n            },\n            validShallow(): boolean {\n                return inst.getErrors(state, 1, undefined, true).length === 0\n            },\n            valid(): boolean {\n                return inst.getErrors(state, Number.MAX_SAFE_INTEGER, undefined, true).length === 0\n            },\n            invalidShallow(): boolean {\n                return inst.getErrors(state, 1, undefined, true).length !== 0\n            },\n            invalid(): boolean {\n                return inst.getErrors(state, Number.MAX_SAFE_INTEGER, undefined, true).length !== 0\n            },\n            errors: (filter, depth, first) => {\n                return inst.getErrors(state, depth === undefined ? Number.MAX_SAFE_INTEGER : depth, filter, first);\n            },\n            firstError: (filter, depth) => {\n                const r = inst.getErrors(state, depth === undefined ? Number.MAX_SAFE_INTEGER : depth, filter, true);\n                if (r.length === 0) {\n                    return {};\n                }\n                return r[0];\n            },\n        }\n    }\n    return {\n        id: PluginID,\n        init: () => new ValidationPluginInstance() as {}\n    }\n}\n"],"names":["self"],"mappings":"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"}